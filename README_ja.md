# Mines [![PyPI](https://img.shields.io/pypi/v/mines-esolang)](https://pypi.org/project/mines-esolang/)

マインスイーパー駆動難解プログラミング言語。

- English version is here: [README.md](README.md)

## 概要

Minesはマインスイーパーをプレイする操作に応じてコマンドを実行するプログラミング言語である。

## 言語仕様

### 設計思想

Minesは主に以下の基準を満たすことを目指して設計されている。

- マインスイーパーらしくあること
- 素直に実装しやすいこと
- 難解プログラミング言語として面白いこと

なお、Minesは[Piet](https://www.dangermouse.net/esoteric/piet.html)の影響を受けて設計されており、ここで言う難解プログラミング言語はPietを想定している場合が多い。

仕様設計にあたり複数の基準が競合するような場合には、なるべく上の方の基準を満たす選択をしている。

### 整数の除算

Minesで扱う整数の除算はすべて[**切り下げ除算**](https://ja.wikipedia.org/wiki/%E5%89%B0%E4%BD%99%E6%BC%94%E7%AE%97#%E5%89%B0%E4%BD%99%E6%BC%94%E7%AE%97%E3%81%AB%E3%82%88%E3%82%8B%E4%BD%99%E3%82%8A%E3%81%AE%E7%AE%97%E5%87%BA)である。

**切り下げ除算**では、有理数として被除数を除数で割った結果を超えない最大の整数を商とする。
これにより、被除数を除数で割り切れない場合は、正負が除数と一致しかつ絶対値が除数未満であるものが剰余となる。

`//` と `%` をそれぞれ切り下げ除算の**商**と**剰余**を表す演算子とする。

#### 整数除算の例

- `5 // 3 = 1` , `5 % 3 = 2`
- `-4 // 3 = -2` , `-4 % 3 = 2`
- `5 // (-3) = -2` , `5 % (-3) = -1`
- `-4 // (-3) = 1` , `-4 % (-3) = -1`

### プログラム仕様

Minesの**プログラム**は1個の**盤面**と1個の**操作リスト**を持つ。

#### 盤面

**盤面**は**列数**と**行数**がいずれも正である矩形のグリッドである。
盤面の**列数**は**幅**、**行数**は**高さ**に対応する。

盤面の**列番号**は `0` から始まり盤面の列数に満たない整数である。
盤面の**行番号**は `0` から始まり盤面の行数に満たない整数である。

盤面はすべての異なる**列番号**と**行番号**の組にそれぞれ1個ずつ対応する**座標**を持つ。
列番号 `i` と行番号 `j` に対応する盤面の**座標**を `(i, j)` と表記する。

盤面の**未正規化列番号**は整数であり、それを盤面の列数で割った剰余を値とする列番号を表す。
盤面の**未正規化行番号**は整数であり、それを盤面の行数で割った剰余を値とする行番号を表す。

盤面はそのすべての座標にそれぞれ1個ずつ対応する**盤面マス**を持つ。
盤面の座標 `(i, j)` に対応する盤面マスの**列番号**を `i` , **行番号**を `j` とする。

**盤面マス**は**安全マス**または**地雷マス**のいずれかである。

2つの異なる盤面マスの行番号の差及び列番号の差がそれぞれ `1` 以下であれば、それらの盤面マスは**隣接**している。

盤面マスは1個の**数字**を持つ。
安全マスの**数字**はそれに隣接している地雷マスの個数である。
地雷マスの**数字**は `9` である。

#### 操作リスト

**操作リスト**は1個以上の**操作**を要素として持つ双方向の循環リストである。

**操作**は**クリック操作**または**切り替え操作**または**無操作**のいずれかである。

**クリック操作**は**座標**と**マウスボタン**を持つ。

クリック操作の**座標**は盤面の座標である。
クリック操作の座標に対応する盤面マスを**操作対象マス**と言う。

**マウスボタン**は**左ボタン**または**右ボタン**のいずれかである。

### 構文規則

Minesのソースコードは単一のUnicode文字列である。

以下、改行は `\n` を指す。

ソースコード内に現れる半角スペース及び `\t\v\f\r` の各文字は無視される。

ソースコードの各行の最初に現れる `#` からその行末（改行を含まない）までの各文字は無視される。

ソースコードは0個以上の**ヘッダー行**と1個の**プログラム**を順に改行で区切って構成される。

**ヘッダー行**は空文字列で表される。

**プログラム**は**盤面**と**操作リスト**を順に改行で区切って表される。

**盤面**はすべての**行**を行番号順に改行で区切って表される。

盤面の**行**はその行に含まれるすべての座標に対応するそれぞれの**盤面マス**を列番号順に繋げて表される。

**安全マス**は `.` で表される。

**地雷マス**は `*` で表される。

**操作リスト**はすべての**操作**を順に改行で区切って表される。

**クリック操作**はその座標を `(i, j)` として、`i` を表す1個の**未正規化列番号**と**マウスボタン**と `j` を表す1個の**未正規化行番号**を順に繋げて表される。

**未正規化列番号**と**未正規化行番号**はそれぞれ正規表現 `/^[+-]?[0-9]+$/` にマッチするように十進法で表される。

**左ボタン**は `,` で表される。

**右ボタン**は `;` で表される。

**切り替え操作**は `!` で表される。

**無操作**は空文字列で表される。

以下に、2個のヘッダー行と列数4行数3の盤面と5個の操作を持つプログラムで構成されるソースコードの例とそれぞれの操作の内容を示す。

```
# You can write header comments.

.*.* # Board is rectangular.
...*
.**.
0,0
-1, -1 # Spaces are ignored.

10;-10
!
```

| 操作    | 内容                                                                       |
| ------- | -------------------------------------------------------------------------- |
| `0,0`   | 座標 `(0, 0)` （左上）、左ボタンのクリック操作                             |
| `-1,-1` | 座標 `(-1 % 4, -1 % 3)` すなわち `(3, 2)` （右下）、左ボタンのクリック操作 |
|         | 無操作                                                                     |
| `9;-10` | 座標 `(9 % 4, -10 % 3)` すなわち `(1, 2)` 、右ボタンのクリック操作         |
| `!`     | 切り替え操作                                                               |

### プログラムの実行規則

#### 実行時の状態

インタプリタはプログラムの実行時に以下の状態を持つ。

- 各盤面マスにそれぞれ対応する**マス状態**
- 1個の**旗立てモード**
- 1個の**操作ポインタ**
- 1個の**操作キュー**
- 1個の**スタック**
- 1個の**入力バッファ**

**マス状態**は**開いていない**または**旗が立っている**または**開いている**のいずれかの値をとる。
マス状態の初期値は**開いていない**である。

マス状態 `A` が盤面マス `B` に対応するとき、`A` を `B` の**状態**と言う。

数字が `0` である盤面マスの状態が**開いていない**から**開いている**になったとき、その盤面マスに隣接している盤面マスのうち状態が**開いていない**であるものはそれぞれ即座に**開いている**になる。

**ゲームオーバー**が発生すると、すべてのマス状態が**開いていない**になる。

**旗立てモード**は**オン**または**オフ**のいずれかの値をとる。
旗立てモードの初期値は**オフ**である。

**操作ポインタ**は操作リスト内の1個の操作を指す。
操作ポインタは初期状態で操作リストの一番最初の操作を指す。

操作ポインタが**進む**というのは、操作ポインタが指す操作が循環リスト内の順方向のリンク先に移動することである。

操作ポインタが**戻る**というのは、操作ポインタが指す操作が循環リスト内の逆方向のリンク先に移動することである。

**操作キュー**は0個以上の操作を持つキューである。
操作キューは初期状態で空である。

**スタック**は0個以上の整数を持つスタックである。
スタックは初期状態で空である。

スタックを**反転する**というのは、以下で定義される処理である。

- スタックが空になるまでスタックからポップし、それらをポップ順にプッシュする。

深さ `d` 、回転数 `r` でスタックを**回転する**というのは、以下で定義される処理である。

- `|d| < 2` または `r = 0` であれば、何もしない。
- `d > 1` かつ `r = 1` であれば、スタックから `d` 回ポップし、最初にポップした要素をプッシュし、残りのポップした要素をポップ順の逆順にプッシュする。
- `d > 1` かつ `r != 1` であれば、深さ `d` 、回転数 `1` でスタックを回転することを `r % d` 回繰り返す。
- `d < -1` であれば、スタックを反転し、深さ `d` 、回転数 `r` でスタックを回転し、再度スタックを反転する。

**入力バッファ**はUnicode文字列である。
入力バッファは標準入力から入力をすべて受け取ったもので初期化される。

入力バッファに**整数**を要求すると、入力バッファは先頭から正規表現 `/^\s*[+-]?[0-9]+$/` にマッチする文字列を取り除き、それを整数にパースして返す。

入力バッファに**Unicodeコードポイント**を要求すると、入力バッファは先頭からUnicodeコードポイントで1単位に相当する文字列を取り除き、それをUnicodeコードポイントに変換して返す。

#### 操作の実行

旗立てモードがオフのとき、**クリック操作**はマウスボタンが左ボタンであれば**左クリック操作**、右ボタンであれば**右クリック操作**として振る舞う。
旗立てモードがオンのときはそれぞれ逆に振る舞う。

**左クリック操作**は操作対象マスの状態が**開いていない**ならば以下を行う。

- 操作対象マスの数字が `9` ならばゲームオーバーを発生させる。
- そうでなければそのマス状態を**開いている**にする。

**右クリック操作**は操作対象マスの状態に応じて以下を行う。

- **開いていない**ならばそれを**旗が立っている**にする。
- **旗が立っている**ならばそれを**開いていない**にする。
- **開いている**ならば、操作対象マスに隣接している盤面マスのうち状態が**旗が立っている**であるものの集合を `F` 、**開いていない**であるものの集合を `U` として以下を行う。

- `F` の要素数が操作対象マスの数字に一致しており、かつ、 `U` の要素数が正ならば、**Chord**を行う。
- **Chord**は以下を行う。
    - `U` に数字が `9` であるものが含まれていれば、ゲームオーバーを発生させる。
    - そうでなければ `U` のそれぞれの状態を**開いている**にする。

**切り替え操作**は旗立てモードがオンであればそれをオフに、オフであればそれをオンにする。

**無操作**は何もしない。

#### コマンド

1個の操作の実行によって1種類の**コマンド**が選択される。

コマンドがその実行フローの最初にスタックから決まった回数だけポップをする場合、その一連のポップを**定数回ポップ**と呼ぶ。

コマンドの実行中にその実行フローを正しく進められない状況に陥った場合、**コマンドエラー**が発生する。

##### コマンド一覧

コマンドは全部で24種類ある。

以下の表はそれぞれのコマンドの名前と実行フローをまとめたものである。

ここで、それぞれの説明に以下を適用する。
- 操作 `A` によってそのコマンドが選択されたものとする。
- `A` の実行中に状態が**開いていない**から**開いている**になった盤面マスの集合を `B` とする。
- コマンドが定数回ポップによってスタックから `n` 回ポップする場合、**ポップ回数**列に `n` を記載する。また、 `i` 番目のポップで取り出された要素を `p(i)` とする。ここで `i` は `0` から始まり `n - 1` で終わる整数とする。

| 名前          | ポップ回数 | 実行フロー                                                                   |
| ------------- | ---------- | ---------------------------------------------------------------------------- |
| `push(n)`     | -          | `A` の操作対象マスの数字をスタックにプッシュ                                 |
| `push(count)` | -          | `B` の要素数をスタックにプッシュ                                             |
| `push(sum)`   | -          | `B` のそれぞれの数字の和をスタックにプッシュ                                 |
| `pop`         | `1`        | 何もしない                                                                   |
| `positive`    | `1`        | `p(0) > 0` ならば `1`、そうでなければ `0` をスタックにプッシュ               |
| `dup`         | `1`        | `p(0)` を2回スタックにプッシュ                                               |
| `add`         | `2`        | `p(1) + p(0)` をスタックにプッシュ                                           |
| `sub`         | `2`        | `p(1) - p(0)` をスタックにプッシュ                                           |
| `mul`         | `2`        | `p(1) * p(0)` をスタックにプッシュ                                           |
| `div`         | `2`        | `p(1) // p(0)`をスタックにプッシュ                                           |
| `mod`         | `2`        | `p(1) % p(0)` をスタックにプッシュ                                           |
| `not`         | `1`        | `p(0) = 0` ならば `1`、そうでなければ `0` をスタックにプッシュ               |
| `roll`        | `2`        | 深さ `p(1)` 、回転数 `p(0)` でスタックを回転する                             |
| `in(n)`       | -          | 入力バッファに整数を要求してスタックにプッシュ                               |
| `in(c)`       | -          | 入力バッファにUnicodeコードポイントを要求してスタックにプッシュ              |
| `out(n)`      | `1`        | `p(0)` を十進数表記で標準出力に出力                                          |
| `out(c)`      | `1`        | Unicodeコードポイントが `p(0)` である文字を標準出力に出力                    |
| `skip`        | `1`        | `p(0) > 0` ならば操作ポインタを `p(0)` 回進め、そうでなければ `-p(0)` 回戻す |
| `perform(l)`  | `2`        | `p(1),p(0)` をパースして得られる操作を操作キューにエンキュー                 |
| `perform(r)`  | `2`        | `p(1);p(0)` をパースして得られる操作を操作キューにエンキュー                 |
| `reset`       | -          | 空になるまでスタックからポップ                                               |
| `swap`        | `2`        | `p(0)` 、 `p(1)` を順にスタックにプッシュ                                    |
| `reverse`     | -          | スタックを反転する                                                           |
| `noop`        | -          | 何もしない                                                                   |

##### コマンドエラー一覧

コマンドエラーは全部で4種類ある。

以下の表はそれぞれのコマンドエラーの名前と発生条件と発生し得るコマンドをまとめたものである。

| 名前                  | 発生条件                                          | コマンド                                               |
| --------------------- | ------------------------------------------------- | ------------------------------------------------------ |
| `StackUnderflowError` | 空のスタックからのポップを試みる                  | 定数回ポップまたはスタックの回転をするすべてのコマンド |
| `ZeroDivisionError`   | `0` を除数とする除算を試みる                      | `div` , `mod`                                          |
| `InputMismatchError`  | 入力バッファが要求された値を返せない              | `in(n)` , `in(c)`                                      |
| `UnicodeRangeError`   | Unicodeコードポイントの範囲外の文字を得ようとする | `out(c)`                                               |

##### コマンド選択フロー

操作 `A` の実行により以下の選択フローでコマンドが選択される。
ここで、 `A` の操作対象マスを `B` 、 `B` の状態を `C` 、 `B` の数字を `D` とする。

- `A` がクリック操作
    - `C` が `A` の実行直前に**開いていない**だった
        - `A` が左クリック操作
            - `A` の実行中にゲームオーバーが発生した -> `noop`
            - `D = 0` -> `push(count)`
            - その他の場合 -> `push(n)`
        - `A` が右クリック操作 -> `swap`
    - `C` が `A` の実行直前に**旗が立っている**だった
        - `A` が左クリック操作 -> `noop`
        - `A` が右クリック操作 -> `swap`
    - `C` が `A` の実行直前に**開いている**だった
        - `A` が左クリック操作
            - `D = 0` -> `pop`
            - `D = 1` -> `positive`
            - `D = 2` -> `dup`
            - `D = 3` -> `add`
            - `D = 4` -> `sub`
            - `D = 5` -> `mul`
            - `D = 6` -> `div`
            - `D = 7` -> `mod`
            - `D = 8` -> `perform(l)`
        - `A` が右クリック操作
            - `A` の実行中にChordが行われた
                - `A` の実行中にゲームオーバーが発生した -> `reset`
                - その他の場合 -> `push(sum)`
            - その他の場合
                - `D = 0` -> `push(n)`
                - `D = 1` -> `not`
                - `D = 2` -> `roll`
                - `D = 3` -> `in(n)`
                - `D = 4` -> `in(c)`
                - `D = 5` -> `out(n)`
                - `D = 6` -> `out(c)`
                - `D = 7` -> `skip`
                - `D = 8` -> `perform(r)`
- `A` が切り替え操作 -> `reverse`
- `A` が無操作 -> `noop`

#### プログラムの実行フロー

インタプリタは以下の手順に1から従ってプログラムを実行する。

1. 各安全マスの状態がそれぞれ**開いている**であれば、プログラムの実行を終了する。
2. 操作ポインタが指している操作を操作キューにエンキューする。
3. 操作キューから1回デキューし、取り出した操作を実行する。
4. その操作の実行によってコマンドを選択する。
5. 選択されたコマンドを実行した場合その実行中にコマンドエラーが発生するかを検証する。
6. コマンドエラーが発生しないという検証結果を得られればそのコマンドを実行する。
7. 操作キューが空でなければ手順3に戻る。
8. 操作ポインタを1回進める。
9. 手順1に戻る。

## 処理系の実装

### 異常系の扱い

処理系がプログラムの実行フローを開始する前に実行時エラーが発生した場合、そのプロセスは異常終了されるべきである。
特に、ソースコードが構文規則を満たしていない場合は、プログラムの実行前に構文エラーが発生し、プロセスが異常終了されるべきである。

プログラムの実行フロー開始以降は、外部割り込み等の止むを得ない場合を除き、言語仕様に違反する挙動の影響でプロセスを終了しないべきである。

例えば、スタックのサイズや整数が取り得る値の範囲は理想的には無限であるが、処理系がそれらを完全に再現するのは難しい。
実際に処理系がそれらの再現性を失った際（典型的にはスタックオーバーフローや算術オーバーフロー等のエラーが発生するタイミング）には、それ以降無操作の実行を無限に繰り返す等の処理に移行するのが望ましい。

なお、コマンドエラーやゲームオーバーの発生は言語仕様に違反する挙動ではない。

### 対話的入力の実装

プログラムの実行中に対話的な入力を受け入れ、適宜入力バッファにエンキューするような実装は可能である。
ただし、一度コマンドによって入力バッファの終端が確認された場合、それ以降にエンキューをするべきではない。

## ソースコード例

- [examples/](examples)

## 実行環境

[uv](https://docs.astral.sh/uv/) でインストールする（推奨）。

```sh
uv tool install mines-esolang
```

`-V` でバージョンを確認する。

```sh
mines -V
```

`-h` でヘルプを表示する。

```sh
mines -h
```

ソースコードのファイルパスを指定してプログラムを実行する。

```sh
mines examples/hello.mines
```

標準入力をファイル入力で置き換える場合は `-i` でファイルパスを指定する。

```sh
mines examples/cat.mines -i examples/cat.mines
```

標準入力を直接文字列で置き換える場合は `-e` で文字列を指定する。

```sh
mines examples/add.mines -e "1 2"
```

適宜リダイレクトやパイプを使用しても良い。

```sh
echo -n "meow" | mines examples/cat.mines
```

`-i` 、 `-e` 、リダイレクトやパイプのいずれも使用しない場合は、適宜対話的な入力を受け付ける。

`-d` でデバッグモードを有効にする。
実行時の状態を確認しながらステップ実行できる。

```sh
mines examples/hello.mines -d
```

## 作者

- [**DNEK**](https://github.com/dnek)

### 関連する制作物

- [Pietron](https://github.com/dnek/pietron) - 難解プログラミング言語PietのIDE。Minesの仕様はPietの影響を受けています。

- [UnambiSweeper](https://dnek.net/ja/unambi) - 最後まで論理的に解けるマインスイーパーアプリ。AndroidとiOSに対応しています。

## ライセンス

このプロジェクトにはMITライセンスが供与されています。
詳細は [LICENSE](LICENSE) ファイルを参照してください。
