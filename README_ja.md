# Mines [![PyPI](https://img.shields.io/pypi/v/mines-esolang)](https://pypi.org/project/mines-esolang/)

<img src="assets/mines_256.png" height="64px" alt="Mines logo">

マインスイーパー駆動[難解プログラミング言語](https://ja.wikipedia.org/wiki/%E9%9B%A3%E8%A7%A3%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E8%A8%80%E8%AA%9E)。

- English version is here: [README.md](README.md)

## 概要

Minesはマインスイーパーをプレイする操作に応じてコマンドを実行するプログラミング言語である。

## デモ

<img src="assets/mines_demo.webp" height="270px" alt="Mines demo">

## 言語仕様

### 設計思想

Minesは主に以下の基準を満たすことを目指して設計されている。

- マインスイーパーらしくあること
- 素直に実装しやすいこと
- 難解プログラミング言語として面白いこと

なお、Minesは[Piet](https://www.dangermouse.net/esoteric/piet.html)の影響を受けて設計されており、ここで言う難解プログラミング言語はPietを想定している場合が多い。

仕様設計にあたり複数の基準が競合するような場合には、なるべく先に挙げた方の基準を満たす選択をしている。

### 整数の除算

Minesで扱う整数の除算はすべて[**切り下げ除算**](https://ja.wikipedia.org/wiki/%E5%89%B0%E4%BD%99%E6%BC%94%E7%AE%97#%E5%89%B0%E4%BD%99%E6%BC%94%E7%AE%97%E3%81%AB%E3%82%88%E3%82%8B%E4%BD%99%E3%82%8A%E3%81%AE%E7%AE%97%E5%87%BA)である。

**切り下げ除算**では、有理数として被除数を除数で割った結果を超えない最大の整数を**商**とする。
これにより、被除数を除数で割り切れない場合は、正負が除数と一致しかつ絶対値が除数未満であるものが**剰余**となる。

`//` と `%` をそれぞれ切り下げ除算の**商**と**剰余**を表す演算子とする。

#### 整数除算の例

- `5 // 3 = 1` , `5 % 3 = 2`
- `-4 // 3 = -2` , `-4 % 3 = 2`
- `5 // (-3) = -2` , `5 % (-3) = -1`
- `-4 // (-3) = 1` , `-4 % (-3) = -1`

### プログラム仕様

Minesの**プログラム**は1個の**盤面**と1個の**操作リスト**を持つ。

#### 盤面

**盤面**は**列数**と**行数**がいずれも正である矩形のグリッドである。
盤面の**列数**は**幅**、**行数**は**高さ**に対応する。

盤面の**列インデックス**は `0` から始まり盤面の列数に満たない整数である。
盤面の**行インデックス**は `0` から始まり盤面の行数に満たない整数である。

盤面はすべての異なる**列インデックス**と**行インデックス**の組にそれぞれ1個ずつ対応する**座標**を持つ。
列インデックス `i` と行インデックス `j` に対応する盤面の**座標**を `(i, j)` と表記する。

盤面の**未正規化列インデックス**は整数であり、それを盤面の列数で割った剰余を値とする列インデックスを表す。
盤面の**未正規化行インデックス**は整数であり、それを盤面の行数で割った剰余を値とする行インデックスを表す。

盤面はそのすべての座標にそれぞれ1個ずつ対応する**盤面マス**を持つ。
盤面の座標 `(i, j)` に対応する盤面マスの**列インデックス**を `i` , **行インデックス**を `j` とする。

**盤面マス**は**安全マス**または**地雷マス**のいずれかである。

2つの異なる盤面マスの行インデックス同士及び列インデックス同士の絶対差がそれぞれ `1` 以下であれば、それらの盤面マスは**隣接**している。

盤面マスは1個の**数字**を持つ。
安全マスの**数字**はそれに隣接している地雷マスの個数である。
地雷マスの**数字**は `9` である。

#### 操作リスト

**操作リスト**は1個以上の**操作**を要素として持つ[片方向循環リスト](https://ja.wikipedia.org/wiki/%E9%80%A3%E7%B5%90%E3%83%AA%E3%82%B9%E3%83%88#%E7%89%87%E6%96%B9%E5%90%91%E5%BE%AA%E7%92%B0%E3%83%AA%E3%82%B9%E3%83%88)である。

**操作**は**クリック操作**または**切り替え操作**または**リスタート操作**または**無操作**のいずれかである。

**クリック操作**は**座標**と**マウスボタン**を持つ。

クリック操作の**座標**は盤面の座標である。
クリック操作の座標に対応する盤面マスを**操作対象マス**と言う。

**マウスボタン**は**左ボタン**または**右ボタン**のいずれかである。

### 構文規則

Minesのソースコードは単一のUnicode文字列である。

以下、改行は `\n` を指す。

ソースコード内に現れる半角スペース、 `\t` 、 `\v` 、 `\f` 、 `\r` の各文字は無視される。

ソースコードの各行ごとに、`#` があればそこからその行末（改行を含まない）までの各文字は無視される。

ソースコードは0個以上の**ヘッダー行**と1個の**プログラム**を順に改行で区切って構成される。

**ヘッダー行**は空文字列で表される。

**プログラム**は**盤面**と**操作リスト**を順に改行で区切って表される。

**盤面**はすべての**行**を行インデックス順に改行で区切って表される。

盤面の行インデックス `i` の**行**はすべての行インデックス `i` の**盤面マス**を列インデックス順に繋げて表される。

**安全マス**は `.` で表される。

**地雷マス**は `*` で表される。

**操作リスト**はすべての**操作**を順に改行で区切って表される。

**クリック操作**はその座標を `(i, j)` として、`i` を表す**未正規化列インデックス**と**マウスボタン**と `j` を表す**未正規化行インデックス**を順に繋げて表される。

**未正規化列インデックス**と**未正規化行インデックス**はそれぞれ正規表現 `/^[+-]?[0-9]+$/` にマッチするように十進法で表される。

**左ボタン**は `,` で表される。

**右ボタン**は `;` で表される。

**切り替え操作**は `!` で表される。

**リスタート操作**は `@` で表される。

**無操作**は空文字列で表される。

#### ソースコードのサンプル

以下に、2個のヘッダー行と列数4行数3の盤面と6個の操作を持つプログラムで構成されるソースコードのサンプルとそれぞれの操作の内容を示す。

```
# You can write header comments.

.*.* # Board is rectangular.
...*
.**.
0,0
-1, -1 # Spaces are ignored.

10;-10
!
@
```

| 操作    | 内容                                                                       |
| ------- | -------------------------------------------------------------------------- |
| `0,0`   | 座標 `(0, 0)` （左上）、左ボタンのクリック操作                             |
| `-1,-1` | 座標 `(-1 % 4, -1 % 3)` すなわち `(3, 2)` （右下）、左ボタンのクリック操作 |
|         | 無操作                                                                     |
| `9;-10` | 座標 `(9 % 4, -10 % 3)` すなわち `(1, 2)` 、右ボタンのクリック操作         |
| `!`     | 切り替え操作                                                               |
| `@`     | リスタート操作                                                             |

### プログラムの実行規則

#### 実行時の状態

インタプリタはプログラムの実行時に以下の状態を持つ。

- 1個の**プレイヤー**
- 1個の**操作ポインタ**
- 1個の**操作キュー**
- 1個の**スタック**
- 1個の**入力バッファ**

##### プレイヤー

**プレイヤー**は以下の状態を持つ。

- 1個の**ゲームステータス**
- 各盤面マスにそれぞれ対応する**マス状態**
- 1個の**旗立てモード**

**ゲームステータス**は**プレイ中**または**クリア**または**オーバー**のいずれかの値をとる。
ゲームステータスの初期値は**プレイ中**である。

**マス状態**は**開いていない**または**旗が立っている**または**開いている**のいずれかの値をとる。
マス状態の初期値は**開いていない**である。

マス状態 `A` が盤面マス `B` に対応するとき、`A` を `B` の**状態**と言う。

数字が `0` である盤面マスの状態が**開いていない**から**開いている**になったとき、その盤面マスに隣接している盤面マスのうち状態が**開いていない**であるものはそれぞれ即座に**開いている**になる。

すべての安全マスの状態がそれぞれ**開いている**になったとき、ゲームステータスは即座に**クリア**になる。

**旗立てモード**は**オン**または**オフ**のいずれかの値をとる。
旗立てモードの初期値は**オフ**である。

##### 操作ポインタ

**操作ポインタ**は操作リスト内の1個の操作を指す。
操作ポインタは初期状態で操作リストの一番最初の操作を指す。

操作ポインタが**進む**というのは、操作ポインタが指す操作が循環リスト内のリンク先に移動することである。

操作ポインタに操作を**要求する**と、操作ポインタは指している操作を返してから1回進む。

##### 操作キュー

**操作キュー**は0個以上の操作を持つキューである。
操作キューは初期状態で空である。

##### スタック

**スタック**は0個以上の整数を持つスタックである。
スタックは初期状態で空である。

スタックを**反転する**というのは、以下で定義される処理である。

- スタックが空になるまでスタックからポップし、それらをポップ順にプッシュする。

深さ `d` 、回転数 `r` でスタックを**回転する**というのは、以下で定義される処理である。

- `|d| < 2` または `r = 0` であれば、何もしない。
- `d > 1` かつ `r = 1` であれば、スタックから `d` 回ポップし、最初にポップした要素をプッシュし、残りのポップした要素をポップ順の逆順にプッシュする。
- `d > 1` かつ `r != 1` であれば、深さ `d` 、回転数 `1` でスタックを回転することを `r % d` 回繰り返す。
- `d < -1` であれば、スタックを反転し、深さ `-d` 、回転数 `r` でスタックを回転し、再度スタックを反転する。

##### 入力バッファ

**入力バッファ**はUnicode文字列である。
入力バッファの初期値は空文字列である。

入力バッファは末尾より後ろの参照を試みられたとき、適宜標準入力から入力を受け取り、末尾に追加してから続けて参照を受ける。
ただし、一度標準入力が `EOF` を示した後は入力を受け取らない。

入力バッファに**整数**を要求すると、入力バッファは先頭から正規表現 `/^\s*[+-]?[0-9]+$/` にマッチする文字列を取り除き、それを整数にパースして返す。

入力バッファに**Unicodeコードポイント**を要求すると、入力バッファは先頭からUnicodeコードポイントで1単位に相当する文字列を取り除き、それをUnicodeコードポイントに変換して返す。

#### 操作の指示

プレイヤーは**操作**を指示されるたびに、それを以下のように実行する。

旗立てモードが**オフ**のとき、**クリック操作**はマウスボタンが左ボタンであれば**左クリック操作**、右ボタンであれば**右クリック操作**として実行される。
旗立てモードが**オン**のときはそれぞれ逆として実行される。

**左クリック操作**の場合、操作対象マスの状態が**開いていない**ならば以下を行う。

- 操作対象マスの数字が `9` ならばゲームステータスを**オーバー**にする。
- そうでなければそのマス状態を**開いている**にする。

**右クリック操作**の場合、操作対象マスの状態に応じて以下を行う。

- **開いていない**ならばそれを**旗が立っている**にする。
- **旗が立っている**ならばそれを**開いていない**にする。
- **開いている**ならば、操作対象マスに隣接している盤面マスのうち状態が**旗が立っている**であるものの集合を `F` 、**開いていない**であるものの集合を `U` として以下を行う。

    - `F` の要素数が操作対象マスの数字に一致しており、かつ、 `U` の要素数が正ならば、**Chord**を行う。
    - **Chord**は以下を行う。
        - `U` に数字が `9` であるものが含まれていればゲームステータスを**オーバー**にする。
        - そうでなければ `U` のそれぞれの状態を**開いている**にする。

**切り替え操作**の場合、旗立てモードが**オン**であればそれを**オフ**に、**オフ**であればそれを**オン**にする。

**リスタート操作**の場合、すべてのマス状態を**開いていない**にして、ゲームステータスを**プレイ中**にする。

**無操作**の場合、何もしない。

#### コマンド

インタプリタはプレイヤーが操作を実行するたびに1種類の**コマンド**を選択する。

コマンドがその実行フローの最初にスタックから決まった回数だけポップをする場合、その一連のポップを**定数回ポップ**と呼ぶ。

コマンドの実行中にその実行フローを正しく進められない状況に陥った場合、**コマンドエラー**が発生する。

##### コマンド一覧

コマンドは全部で25種類ある。

以下の表はそれぞれのコマンドの名前と実行フローをまとめたものである。

ここで、それぞれの説明に以下を適用する。
- プレイヤーが操作 `A` を実行したことでそのコマンドが選択されたものとする。
- `A` の実行中に状態が**開いていない**から**開いている**になった盤面マスの集合を `B` とする。
- コマンドが定数回ポップによってスタックから `n` 回ポップする場合、**ポップ回数**列に `n` を記載する。また、 `i` 番目のポップで取り出された要素を `p(i)` とする。ここで `i` は `0` から始まり `n - 1` で終わる整数とする。

| 名前          | ポップ回数 | 実行フロー（定数回ポップを除く）                                         |
| ------------- | ---------- | ------------------------------------------------------------------------ |
| `push(n)`     | -          | `A` の操作対象マスの数字をスタックにプッシュ                             |
| `push(count)` | -          | `B` の要素数をスタックにプッシュ                                         |
| `push(sum)`   | -          | `B` のそれぞれの数字の和をスタックにプッシュ                             |
| `pop`         | `1`        | 何もしない                                                               |
| `positive`    | `1`        | `p(0) > 0` ならば `1`、そうでなければ `0` をスタックにプッシュ           |
| `dup`         | `1`        | `p(0)` を2回スタックにプッシュ                                           |
| `add`         | `2`        | `p(1) + p(0)` をスタックにプッシュ                                       |
| `sub`         | `2`        | `p(1) - p(0)` をスタックにプッシュ                                       |
| `mul`         | `2`        | `p(1) * p(0)` をスタックにプッシュ                                       |
| `div`         | `2`        | `p(1) // p(0)`をスタックにプッシュ                                       |
| `mod`         | `2`        | `p(1) % p(0)` をスタックにプッシュ                                       |
| `not`         | `1`        | `p(0) = 0` ならば `1`、そうでなければ `0` をスタックにプッシュ           |
| `roll`        | `2`        | 深さ `p(1)` 、回転数 `p(0)` でスタックを回転する                         |
| `in(n)`       | -          | 入力バッファに整数を要求してスタックにプッシュ                           |
| `in(c)`       | -          | 入力バッファにUnicodeコードポイントを要求してスタックにプッシュ          |
| `out(n)`      | `1`        | `p(0)` を十進数表記で標準出力に出力                                      |
| `out(c)`      | `1`        | Unicodeコードポイントが `p(0)` である文字を標準出力に出力                |
| `skip`        | `1`        | 操作リストの長さを `l` として操作ポインタを `p(0) % l` 回進める          |
| `perform(l)`  | `2`        | `p(1),p(0)` をパースして得られる操作を操作キューにエンキュー             |
| `perform(r)`  | `2`        | `p(1);p(0)` をパースして得られる操作を操作キューにエンキュー             |
| `reset(l)`    | -          | リスタート操作を操作キューにエンキュー                                   |
| `reset(r)`    | -          | 空になるまでスタックからポップし、リスタート操作を操作キューにエンキュー |
| `swap`        | `2`        | `p(0)` 、 `p(1)` を順にスタックにプッシュ                                |
| `reverse`     | -          | スタックを反転する                                                       |
| `noop`        | -          | 何もしない                                                               |

##### コマンドエラー一覧

コマンドエラーは全部で4種類ある。

以下の表はそれぞれのコマンドエラーの名前と発生条件と発生し得るコマンドをまとめたものである。

| 名前                  | 発生条件                                          | コマンド                                               |
| --------------------- | ------------------------------------------------- | ------------------------------------------------------ |
| `StackUnderflowError` | 空のスタックからのポップを試みる                  | 定数回ポップまたはスタックの回転をするすべてのコマンド |
| `ZeroDivisionError`   | `0` を除数とする除算を試みる                      | `div` , `mod`                                          |
| `InputMismatchError`  | 入力バッファが要求された値を返せない              | `in(n)` , `in(c)`                                      |
| `UnicodeRangeError`   | Unicodeコードポイントの範囲外の文字を得ようとする | `out(c)`                                               |

##### コマンド選択フロー

操作 `A` の実行により以下の選択フローでコマンドが選択される。
ここで、 `A` の操作対象マスについて、 `A` の実行直前の状態を `B` 、 数字を `C` とする。

- `A` が左クリック操作
    - `B` が**開いていない**だった
        - `C = 0` -> `push(count)`
        - `0 < C < 9` -> `push(n)`
        - `C = 9` -> `reset(l)`
    - `B` が**旗が立っている**だった -> `noop`
    - `B` が**開いている**だった
        - `C = 0` -> `pop`
        - `C = 1` -> `positive`
        - `C = 2` -> `dup`
        - `C = 3` -> `add`
        - `C = 4` -> `sub`
        - `C = 5` -> `mul`
        - `C = 6` -> `div`
        - `C = 7` -> `mod`
        - `C = 8` -> `perform(l)`
- `A` が右クリック操作 -> `swap`
    - `B` が**開いていない**だった -> `swap`
    - `B` が**旗が立っている**だった -> `swap`
    - `B` が**開いている**だった
        - Chordが行われた
            - ゲームステータスが**オーバー**になった -> `reset(r)`
            - その他の場合 -> `push(sum)`
        - Chordが行われなかった
            - `C = 0` -> `push(n)`
            - `C = 1` -> `not`
            - `C = 2` -> `roll`
            - `C = 3` -> `in(n)`
            - `C = 4` -> `in(c)`
            - `C = 5` -> `out(n)`
            - `C = 6` -> `out(c)`
            - `C = 7` -> `skip`
            - `C = 8` -> `perform(r)`
- `A` が切り替え操作 -> `reverse`
- `A` がリスタート操作 -> `noop`
- `A` が無操作 -> `noop`

#### プログラムの実行フロー

インタプリタは以下の手順に1から従ってプログラムを実行する。

1. ゲームステータスが**クリア**であれば、プログラムの実行を終了する。
2. 操作キューが空であれば、操作ポインタに操作を要求してエンキューする。
3. 操作キューからデキューし、取り出した操作をプレイヤーに指示する。
4. プレイヤーが操作を実行したことによりコマンドを選択する。
5. 選択されたコマンドを実行した場合にコマンドエラーが発生するかを検証する。
6. コマンドエラーが発生しないという検証結果を得られれば、そのコマンドを実行する。
7. 手順1に戻る。

## 処理系の実装

処理系がプログラムの実行フローを開始する前に実行時エラーが発生した場合、そのプロセスは異常終了されるべきである。
特に、ソースコードが構文規則を満たしていない場合は、プログラムの実行前に構文エラーが発生し、プロセスが異常終了されるべきである。

プログラムの実行フロー開始以降は、外部割り込み等の止むを得ない場合を除き、言語仕様に違反する挙動の影響でプロセスを終了しないべきである。

例えば、スタックのサイズや整数が取り得る値の範囲は理想的には無限であるが、処理系がそれらを完全に再現するのは難しい。
実際に処理系がそれらの再現性を失った際（典型的にはスタックオーバーフローや算術オーバーフロー等のエラーが発生するタイミング）には、それ以降無操作の実行を無限に繰り返す等の処理に移行するのが望ましい。

なお、以下は言語仕様に違反する挙動ではない。

- コマンドエラーが発生するという検証結果を得る
- ゲームステータスが**オーバー**になる

## 実例

- [examples/](examples)

## 実行環境

### インストール

- [uv](https://docs.astral.sh/uv/)（推奨）

```sh
uv tool install mines-esolang
```

- [pipx](https://pipx.pypa.io/stable/)

```sh
pipx install mines-esolang
```

- ソースから

```sh
git clone https://github.com/dnek/mines-esolang
cd mines-esolang
uv tool install -e .
```

### アンインストール

```sh
uv tool uninstall mines-esolang
```

```sh
pipx uninstall mines-esolang
```

### 使用方法

`-V` でバージョンを確認する。

```sh
mines -V
```

`-h` でヘルプを表示する。

```sh
mines -h
```

ソースコードのファイルパスを指定してプログラムを実行する。

```sh
mines examples/hello.mines
```

標準入力をファイル入力で置き換える場合は `-i` でファイルパスを指定する。

```sh
mines examples/cat.mines -i examples/cat.mines
```

標準入力を直接文字列で置き換える場合は `-e` で文字列を指定する。

```sh
mines examples/add.mines -e "1 2"
```

適宜リダイレクトやパイプを使用しても良い。

```sh
echo -n "🐱meow" | mines examples/cat.mines
```

`-i` 、 `-e` 、リダイレクトやパイプのいずれも使用しない場合は適宜対話的な入力を受け付ける。

`-d` でデバッグモードを有効にする。
実行時の状態を確認しながらステップ実行できる。

```sh
mines examples/hello.mines -d
```

ただし、リダイレクトやパイプにより標準入力が端末に接続されていない場合はデバッグモードを実行できない。

### おまけ

`mines-esolang` をインストールすると、通常のマインスイーパーゲームをプレイできるコマンド `mines-game` も追加される。

`-l` でレベルを指定してプレイする。
レベルは `beginner` 、 `intermediate` 、 `expert` 、またはそれぞれの頭文字を指定する。

```sh
mines-game -l b
```

`-c` で盤面の幅、高さ、地雷の個数を指定してプレイする。

```sh
mines-game -c 48 24 256
```

ソースコードのファイルパスを指定すると、そのプログラムの盤面をプレイできる。

```sh
mines-game examples/hello.mines
```

プログラムの盤面をプレイする場合以外は、最初に開くマスの数字が `0` になるように地雷が配置される。

## 作者

- [**DNEK**](https://github.com/dnek)

## 関連するプロジェクト

- [Mines Web Interpreter](https://mug.sh/mines-editor/) by [sh-mug](https://github.com/sh-mug)

    Minesのコードエディタとインタプリタを提供するウェブアプリ。

- [Pietron](https://github.com/dnek/pietron) by DNEK

    難解プログラミング言語PietのIDE。

- [UnambiSweeper](https://dnek.net/ja/unambi) by DNEK

    最後まで論理的に解けるマインスイーパーアプリ。
    AndroidとiOSに対応しています。

## ライセンス

このプロジェクトにはMITライセンスが供与されています。
詳細は [LICENSE](LICENSE) ファイルを参照してください。
